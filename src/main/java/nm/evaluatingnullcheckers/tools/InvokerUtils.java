package nm.evaluatingnullcheckers.tools;

import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.lang.annotation.Annotation;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;

import com.fasterxml.jackson.core.JsonParseException;
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.JsonMappingException;
import com.fasterxml.jackson.databind.ObjectMapper;

/**
 * Class containing several utility methods / classes for the invoker
 * 
 * @author Nick Mazey
 *
 */
public class InvokerUtils {

	public enum CheckerOutput {
		VULNERABLE, SAFE, ERROR;
	}

	public enum KnownChecker {
		CHECKERFRAMEWORK, INFER, NULLAWAY;
	}

	public enum Flag {
		TRUEPOSITIVE, FALSEPOSITIVE, TRUENEGATIVE, FALSENEGATIVE, ERROR;
	}

	private static void invalidOutputFile(File file){
		throw new IllegalArgumentException("ERROR - \"" + file +"\" is not a valid output file");
	}

	private static void fileNotFound(File file){
		throw new IllegalArgumentException("ERROR - \"" + file +"\" could not be found");
	}

	private static void invalidJson(File file){
		throw new IllegalArgumentException("ERROR - \"" + file + "\" does not contain valid json");
	}

	/**
	 * Converts processed outputs into a JSON file
	 * 
	 * @param outputs - Outputs generated by parseReports
	 * @param file    - The file for writing output to
	 */
	public static void outputReportsToFile(HashMap<KnownChecker, ArrayList<CheckerReport>> outputs, File file) {
		ObjectMapper mapper = new ObjectMapper();
		try {
			String output = mapper.writeValueAsString(outputs);
			FileWriter writer = new FileWriter(file);
			writer.write(output);
			writer.close();
		} catch (IOException e) {
			invalidOutputFile(file);
		}
	}

	/**
	 * Method for deserialising reports from the checker output parser
	 * 
	 * @param file - The file to deserialise
	 * @return - The report de-serialised
	 */
	public static HashMap<KnownChecker, ArrayList<CheckerReport>> deserialiseReports(File file) {
		ObjectMapper mapper = new ObjectMapper();
		TypeReference<HashMap<KnownChecker, ArrayList<CheckerReport>>> outputRef = new TypeReference<>() {
		};
		try {
			HashMap<KnownChecker, ArrayList<CheckerReport>> output = mapper.readValue(file, outputRef);
			return output;
		} catch (JsonParseException e) {
			invalidJson(file);
		} catch (IOException e) {
			fileNotFound(file);
		}
		return new HashMap<>();
	}

	/**
	 * Writes results to a file in JSON format
	 * 
	 * @param results - Results map to write
	 * @param file    - File for writing
	 */
	public static void outputResultsToFile(HashMap<KnownChecker, CheckerResult> results, File file) {
		ObjectMapper mapper = new ObjectMapper();
		try {
			String output = mapper.writeValueAsString(results);
			FileWriter writer = new FileWriter(file);
			writer.write(output);
			writer.close();
		} catch (IOException e) {
			invalidOutputFile(file);
		}
	}

	/**
	 * Method for de-serialising results from checker evaluator
	 * 
	 * @param file - JSON file to read from
	 * @return - The results de-serialised
	 */
	public static HashMap<KnownChecker, CheckerResult> deserialiseResults(File file) {
		ObjectMapper mapper = new ObjectMapper();
		TypeReference<HashMap<KnownChecker, CheckerResult>> outputRef = new TypeReference<HashMap<KnownChecker, CheckerResult>>() {
		};
		try {
			HashMap<KnownChecker, CheckerResult> output = mapper.readValue(file, outputRef);
			return output;
		} catch (JsonParseException e) {
			invalidJson(file);
		} catch (IOException e) {
			fileNotFound(file);
		}
		return new HashMap<>();
	}
	
	/**
	 * Method for creating a list of subject names used in results from the checker evaluator
	 * 
	 * @param results - Results produced by a checker evaluator
	 * @return - ArrayList of all unique subject names in the results map
	 */
	public static ArrayList<String> getSubjectsFromResults(HashMap<KnownChecker, CheckerResult> results){
		ArrayList<String> subjects = new ArrayList<String>();
		for (CheckerResult checkerResult : results.values()) {
			for(String subject : checkerResult.getSubjectResults().keySet()) {
				if(!subjects.contains(subject)) {
					subjects.add(subject);
				}
			}
		}
		return subjects;
	}
	
	/**
	 * Gets all metadata for specified benchmarks
	 * 
	 * @param names - The simple class names to search for
	 * @return - Map from class name to annotations
	 */
	public static HashMap<String, ArrayList<Annotation>> getMetadata(ArrayList<String> names) {
		HashMap<String, ArrayList<Annotation>> metadata = new HashMap<String, ArrayList<Annotation>>();
		if (names != null) {
			HashSet<Class<?>> benchmarkClasses = BenchmarkSpace.getAllBenchmarkClasses();
			for (Class<?> clazz : benchmarkClasses) {
				String simpleName = clazz.getSimpleName();
				if (names.contains(simpleName)) {
					ArrayList<Annotation> annotations = new ArrayList<Annotation>();
					for (Annotation annotation : clazz.getAnnotations()) {
						annotations.add(annotation);
					}
					metadata.put(simpleName, annotations);
				}
			}
		}
		return metadata;
	}

}
