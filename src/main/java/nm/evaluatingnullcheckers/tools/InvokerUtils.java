package nm.evaluatingnullcheckers.tools;

import java.io.*;
import java.lang.annotation.Annotation;
import java.util.*;

import com.fasterxml.jackson.core.JacksonException;
import com.fasterxml.jackson.core.JsonParseException;
import com.fasterxml.jackson.core.JsonParser;
import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.DeserializationContext;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.deser.std.StdDeserializer;
import com.fasterxml.jackson.databind.exc.InvalidFormatException;
import com.fasterxml.jackson.databind.module.SimpleModule;

/**
 * Class containing several utility methods / classes for the invoker
 * 
 * @author Nick Mazey
 *
 */
public class InvokerUtils {

	/**
	 * Finds all benchmark classes
	 * @return - A hashset containing all benchmark classes
	 */
	public static HashSet<Class<?>> getAllBenchmarkClasses(){
		HashSet<Class<?>> benchmarks = new HashSet<>();
		String packageName = "nm.evaluatingnullcheckers.benchmarks";
		InputStream stream = ClassLoader.getSystemClassLoader().getResourceAsStream(packageName.replaceAll("[.]", "/"));
		BufferedReader reader = new BufferedReader(new InputStreamReader(stream));
		String str;
		try {
			for(str = reader.readLine(); str !=null;str = reader.readLine()) {
				//Ignore subclasses
				if(!str.contains("$")) {
					benchmarks.add(Class.forName(packageName + "." + str.substring(0,str.lastIndexOf("."))));
				}
			}
		}catch(Exception e) {
			e.printStackTrace();
		}
		return benchmarks;
	}

	public enum CheckerOutput {
		VULNERABLE, SAFE, ERROR
	}


	public enum Flag {
		TRUEPOSITIVE, FALSEPOSITIVE, TRUENEGATIVE, FALSENEGATIVE, ERROR
	}

	private static void invalidOutputFile(File file){
		throw new IllegalArgumentException("ERROR - \"" + file +"\" is not a valid output file");
	}

	private static void fileNotFound(File file){
		throw new IllegalArgumentException("ERROR - \"" + file +"\" could not be found");
	}

	private static void invalidJson(File file){
		throw new IllegalArgumentException("ERROR - \"" + file + "\" does not contain valid json");
	}

	private static void folderNotFound(File folder){
		throw new IllegalArgumentException("ERROR - folder \"" + folder +"\" could not be found");
	}

	/**
	 * Converts processed outputs into a JSON file
	 * 
	 * @param outputs - Outputs generated by parseReports
	 * @param file    - The file for writing output to
	 */
	public static void outputReportsToFile(HashMap<String, ArrayList<CheckerReport>> outputs, File file) {
		ObjectMapper mapper = new ObjectMapper();
		try {
			String output = mapper.writeValueAsString(outputs);
			FileWriter writer = new FileWriter(file);
			writer.write(output);
			writer.close();
		} catch (IOException e) {
			invalidOutputFile(file);
		}
	}

	/**
	 * Method for deserialising reports from the checker output parser
	 * 
	 * @param file - The file to deserialise
	 * @return - The report de-serialised
	 */
	public static HashMap<String, ArrayList<CheckerReport>> deserialiseReports(File file) {
		ObjectMapper mapper = new ObjectMapper();
		TypeReference<HashMap<String, ArrayList<CheckerReport>>> outputRef = new TypeReference<>() {
		};
		try {
			return mapper.readValue(file, outputRef);
		} catch (JsonParseException e) {
			invalidJson(file);
		} catch (IOException e) {
			fileNotFound(file);
		}
		return new HashMap<>();
	}

	/**
	 * Writes results to a file in JSON format
	 * 
	 * @param results - Results map to write
	 * @param file    - File for writing
	 */
	public static void outputResultsToFile(HashMap<String, CheckerResult> results, File file) {
		ObjectMapper mapper = new ObjectMapper();
		try {
			String output = mapper.writeValueAsString(results);
			FileWriter writer = new FileWriter(file);
			writer.write(output);
			writer.close();
		} catch (IOException e) {
			invalidOutputFile(file);
		}
	}

	/**
	 * Method for de-serialising results from checker evaluator
	 * 
	 * @param file - JSON file to read from
	 * @return - The results de-serialised
	 */
	public static HashMap<String, CheckerResult> deserialiseResults(File file) {
		ObjectMapper mapper = new ObjectMapper();
		TypeReference<HashMap<String, CheckerResult>> outputRef = new TypeReference<>() {
		};
		try {
			return mapper.readValue(file, outputRef);
		} catch (JsonParseException e) {
			invalidJson(file);
		} catch (IOException e) {
			fileNotFound(file);
		}
		return new HashMap<>();
	}
	
	/**
	 * Method for creating a list of subject names used in results from the checker evaluator
	 * 
	 * @param results - Results produced by a checker evaluator
	 * @return - ArrayList of all unique subject names in the results map
	 */
	public static ArrayList<String> getSubjectsFromResults(HashMap<String, CheckerResult> results){
		ArrayList<String> subjects = new ArrayList<>();
		for (CheckerResult checkerResult : results.values()) {
			for(String subject : checkerResult.getSubjectResults().keySet()) {
				if(!subjects.contains(subject)) {
					subjects.add(subject);
				}
			}
		}
		return subjects;
	}
	
	/**
	 * Gets all metadata for specified benchmarks
	 * 
	 * @param names - The simple class names to search for
	 * @return - Map from class name to annotations
	 */
	public static HashMap<String, ArrayList<Annotation>> getMetadata(ArrayList<String> names) {
		HashMap<String, ArrayList<Annotation>> metadata = new HashMap<>();
		if (names != null) {
			HashSet<Class<?>> benchmarkClasses = getAllBenchmarkClasses();
			for (Class<?> clazz : benchmarkClasses) {
				String simpleName = clazz.getSimpleName();
				if (names.contains(simpleName)) {
					ArrayList<Annotation> annotations = new ArrayList<>();
					Collections.addAll(annotations, clazz.getAnnotations());
					metadata.put(simpleName, annotations);
				}
			}
		}
		return metadata;
	}

	private static final class OutputPatternDeserializer extends StdDeserializer<OutputPattern>{

		private int depth = 0;

		public OutputPatternDeserializer(Class<?> vc){
			super(vc);
		}

		private OutputPattern deserialize(JsonNode node){
			if(node == null || node.isNull()){
				return null;
			}
			depth +=1;
			if(depth > 5){
				throw new IllegalArgumentException("Auxiliary pattern maximum depth of 5 cannot be exceeded.");
			}
			return OutputPattern.of(node.get("vulnerableRegex").asText(),node.get("errorRegex").asText(),node.get("fileExtension").asText(),deserialize(node.get("auxPattern")));
		}

		@Override
		public OutputPattern deserialize(JsonParser p, DeserializationContext ctxt) throws IOException, JacksonException {
			depth = 0;
			return deserialize(p.getCodec().readTree(p));
		}
	}

	public static List<String> getAvailableCheckers(){
		List<String> availableCheckers = new ArrayList<>();
		File folder = new File("scripts");
		try {
			if(!folder.exists() || !folder.isDirectory()){folderNotFound(folder);}
			for(File script : folder.listFiles()){
				String ending = "script.sh";
				if(script.getName().endsWith(ending)){
					availableCheckers.add(script.getName().substring(0,script.getName().length()-ending.length()).toUpperCase());
				}
			}
		} catch (Exception e){
			throw new RuntimeException(e);
		}
		return availableCheckers;
	}

	public static HashMap<String,OutputPattern> getOutputPatterns(){
		ObjectMapper mapper = new ObjectMapper();
		SimpleModule module = new SimpleModule();
		HashMap<String,OutputPattern> checkerOutputPatterns = new HashMap<>();
		module.addDeserializer(OutputPattern.class,new OutputPatternDeserializer(OutputPattern.class));
		mapper.registerModule(module);
		File folder = new File("outputpatterns");
		try{
			if(!folder.exists() || !folder.isDirectory()){folderNotFound(folder);}
			for(File pattern : folder.listFiles()){
				if(pattern.getName().endsWith(".json")){
					String checkerName = pattern.getName().substring(0,pattern.getName().length()-5).toLowerCase();
					checkerOutputPatterns.put(checkerName.toUpperCase(),mapper.readValue(pattern,OutputPattern.class));
				}
			}
		} catch (Exception e){
			throw new RuntimeException(e);
		}
		return checkerOutputPatterns;
	}

}
